function e(){return(e=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}function t(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)t.indexOf(r=i[n])>=0||(o[r]=e[r]);return o}function r(e){return"[object Object]"===Object.prototype.toString.call(e)}const n={silent:!1},o=["validator"],i=Object.prototype,a=i.toString,s=i.hasOwnProperty,u=/^\s*function (\w+)/;function l(e){var t;const r=null!==(t=null==e?void 0:e.type)&&void 0!==t?t:e;if(r){const e=r.toString().match(u);return e?e[1]:""}return""}const c=function(e){var t,n;return!1!==r(e)&&(void 0===(t=e.constructor)||!1!==r(n=t.prototype)&&!1!==n.hasOwnProperty("isPrototypeOf"))},f=e=>e;let d=f;if("production"!==process.env.NODE_ENV){const e="undefined"!=typeof console;d=e?function(e){!1===n.silent&&console.warn(`[VueTypes warn]: ${e}`)}:f}const p=(e,t)=>s.call(e,t),y=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},v=Array.isArray||function(e){return"[object Array]"===a.call(e)},h=e=>"[object Function]"===a.call(e),b=e=>c(e)&&p(e,"_vueTypes_name"),g=e=>c(e)&&(p(e,"type")||["_vueTypes_name","validator","default","required"].some(t=>p(e,t)));function O(e,t){return Object.defineProperty(e.bind(t),"__original",{value:e})}function m(e,t,r=!1){let n,o=!0,i="";n=c(e)?e:{type:e};const a=b(n)?n._vueTypes_name+" - ":"";if(g(n)&&null!==n.type){if(void 0===n.type||!0===n.type)return o;if(!n.required&&void 0===t)return o;v(n.type)?(o=n.type.some(e=>!0===m(e,t,!0)),i=n.type.map(e=>l(e)).join(" or ")):(i=l(n),o="Array"===i?v(t):"Object"===i?c(t):"String"===i||"Number"===i||"Boolean"===i||"Function"===i?function(e){if(null==e)return"";const t=e.constructor.toString().match(u);return t?t[1]:""}(t)===i:t instanceof n.type)}if(!o){const e=`${a}value "${t}" should be of type "${i}"`;return!1===r?(d(e),!1):e}if(p(n,"validator")&&h(n.validator)){const e=d,i=[];if(d=e=>{i.push(e)},o=n.validator(t),d=e,!o){const e=(i.length>1?"* ":"")+i.join("\n* ");return i.length=0,!1===r?(d(e),o):e}}return o}function j(e,t){const r=Object.defineProperties(t,{_vueTypes_name:{value:e,writable:!0},isRequired:{get(){return this.required=!0,this}},def:{value(e){return void 0===e?(p(this,"default")&&delete this.default,this):h(e)||!0===m(this,e,!0)?(this.default=v(e)?()=>[...e]:c(e)?()=>Object.assign({},e):e,this):(d(`${this._vueTypes_name} - invalid default value: "${e}"`),this)}}}),{validator:n}=r;return h(n)&&(r.validator=O(n,r)),r}function _(e,t){const r=j(e,t);return Object.defineProperty(r,"validate",{value(e){return h(this.validator)&&d(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:\n${JSON.stringify(this)}`),this.validator=O(e,this),this}})}function T(e,r,n){const i=function(e){const t={};return Object.getOwnPropertyNames(e).forEach(r=>{t[r]=Object.getOwnPropertyDescriptor(e,r)}),Object.defineProperties({},t)}(r);if(i._vueTypes_name=e,!c(n))return i;const{validator:a}=n,s=t(n,o);if(h(a)){let{validator:e}=i;e&&(e=null!==(l=(u=e).__original)&&void 0!==l?l:u),i.validator=O(e?function(t){return e.call(this,t)&&a.call(this,t)}:a,i)}var u,l;return Object.assign(i,s)}function $(e){return e.replace(/^(?!\s*$)/gm,"  ")}const w=()=>_("any",{}),P=()=>_("function",{type:Function}),x=()=>_("boolean",{type:Boolean}),E=()=>_("string",{type:String}),N=()=>_("number",{type:Number}),q=()=>_("array",{type:Array}),A=()=>_("object",{type:Object}),S=()=>j("integer",{type:Number,validator:e=>y(e)}),V=()=>j("symbol",{validator:e=>"symbol"==typeof e});function k(e,t="custom validation failed"){if("function"!=typeof e)throw new TypeError("[VueTypes error]: You must provide a function as argument");return j(e.name||"<<anonymous function>>",{validator(r){const n=e(r);return n||d(`${this._vueTypes_name} - ${t}`),n}})}function D(e){if(!v(e))throw new TypeError("[VueTypes error]: You must provide an array as argument.");const t=`oneOf - value should be one of "${e.join('", "')}".`,r=e.reduce((e,t)=>{if(null!=t){const r=t.constructor;-1===e.indexOf(r)&&e.push(r)}return e},[]);return j("oneOf",{type:r.length>0?r:void 0,validator(r){const n=-1!==e.indexOf(r);return n||d(t),n}})}function F(e){if(!v(e))throw new TypeError("[VueTypes error]: You must provide an array as argument");let t=!1,r=[];for(let n=0;n<e.length;n+=1){const o=e[n];if(g(o)){if(b(o)&&"oneOf"===o._vueTypes_name&&o.type){r=r.concat(o.type);continue}if(h(o.validator)&&(t=!0),!0!==o.type&&o.type){r=r.concat(o.type);continue}}r.push(o)}return r=r.filter((e,t)=>r.indexOf(e)===t),j("oneOfType",t?{type:r,validator(t){const r=[],n=e.some(e=>{const n=m(b(e)&&"oneOf"===e._vueTypes_name?e.type||null:e,t,!0);return"string"==typeof n&&r.push(n),!0===n});return n||d(`oneOfType - provided value does not match any of the ${r.length} passed-in validators:\n${$(r.join("\n"))}`),n}}:{type:r})}function L(e){return j("arrayOf",{type:Array,validator(t){let r="";const n=t.every(t=>(r=m(e,t,!0),!0===r));return n||d(`arrayOf - value validation error:\n${$(r)}`),n}})}function Y(e){return j("instanceOf",{type:e})}function B(e){return j("objectOf",{type:Object,validator(t){let r="";const n=Object.keys(t).every(n=>(r=m(e,t[n],!0),!0===r));return n||d(`objectOf - value validation error:\n${$(r)}`),n}})}function I(e){const t=Object.keys(e),r=t.filter(t=>{var r;return!(null===(r=e[t])||void 0===r||!r.required)}),n=j("shape",{type:Object,validator(n){if(!c(n))return!1;const o=Object.keys(n);if(r.length>0&&r.some(e=>-1===o.indexOf(e))){const e=r.filter(e=>-1===o.indexOf(e));return d(1===e.length?`shape - required property "${e[0]}" is not defined.`:`shape - required properties "${e.join('", "')}" are not defined.`),!1}return o.every(r=>{if(-1===t.indexOf(r))return!0===this._vueTypes_isLoose||(d(`shape - shape definition does not include a "${r}" property. Allowed keys: "${t.join('", "')}".`),!1);const o=m(e[r],n[r],!0);return"string"==typeof o&&d(`shape - "${r}" property validation error:\n ${$(o)}`),!0===o})}});return Object.defineProperty(n,"_vueTypes_isLoose",{writable:!0,value:!1}),Object.defineProperty(n,"loose",{get(){return this._vueTypes_isLoose=!0,this}}),n}const J=["name","validate","getter"],M=(()=>{var e,r;return r=e=class{static get any(){return w()}static get func(){return P().def(this.defaults.func)}static get bool(){return x().def(this.defaults.bool)}static get string(){return E().def(this.defaults.string)}static get number(){return N().def(this.defaults.number)}static get array(){return q().def(this.defaults.array)}static get object(){return A().def(this.defaults.object)}static get integer(){return S().def(this.defaults.integer)}static get symbol(){return V()}static extend(e){if(v(e))return e.forEach(e=>this.extend(e)),this;const{name:r,validate:n=!1,getter:o=!1}=e,i=t(e,J);if(p(this,r))throw new TypeError(`[VueTypes error]: Type "${r}" already defined`);const{type:a}=i;if(b(a))return delete i.type,Object.defineProperty(this,r,o?{get:()=>T(r,a,i)}:{value(...e){const t=T(r,a,i);return t.validator&&(t.validator=t.validator.bind(t,...e)),t}});let s;return s=o?{get(){const e=Object.assign({},i);return n?_(r,e):j(r,e)},enumerable:!0}:{value(...e){const t=Object.assign({},i);let o;return o=n?_(r,t):j(r,t),t.validator&&(o.validator=t.validator.bind(o,...e)),o},enumerable:!0},Object.defineProperty(this,r,s)}},e.defaults={},e.sensibleDefaults=void 0,e.config=n,e.custom=k,e.oneOf=D,e.instanceOf=Y,e.oneOfType=F,e.arrayOf=L,e.objectOf=B,e.shape=I,e.utils={validate:(e,t)=>!0===m(t,e,!0),toType:(e,t,r=!1)=>r?_(e,t):j(e,t)},r})();function R(t={func:()=>{},bool:!0,string:"",number:0,array:()=>[],object:()=>({}),integer:0}){var r,n;return n=r=class extends M{static get sensibleDefaults(){return e({},this.defaults)}static set sensibleDefaults(r){this.defaults=!1!==r?e({},!0!==r?r:t):{}}},r.defaults=e({},t),n}class z extends(R()){}export default z;export{w as any,q as array,L as arrayOf,x as bool,n as config,R as createTypes,k as custom,T as fromType,P as func,Y as instanceOf,S as integer,N as number,A as object,B as objectOf,D as oneOf,F as oneOfType,I as shape,E as string,V as symbol,j as toType,_ as toValidableType,m as validateType};
//# sourceMappingURL=vue-types.modern.js.map
